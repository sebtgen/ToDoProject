import { Component, ChangeDetectionStrategy, Input, ViewChildren } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { filter } from 'rxjs/operators';
import { HotToastComponent } from '../hot-toast/hot-toast.component';
import { HOT_TOAST_DEPTH_SCALE, HOT_TOAST_DEPTH_SCALE_ADD, HOT_TOAST_MARGIN } from '../../constants';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class HotToastContainerComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.toasts = [];
        this.toastRefs = [];
        this.isShowingAllToasts = false;
        /** Subject for notifying the user that the toast has been closed. */
        this._onClosed = new Subject();
        this.onClosed$ = this._onClosed.asObservable();
    }
    trackById(index, toast) {
        return toast.id;
    }
    getVisibleToasts(position) {
        return this.toasts.filter((t) => t.visible && t.position === position);
    }
    calculateOffset(toastId, position) {
        const visibleToasts = this.getVisibleToasts(position);
        const index = visibleToasts.findIndex((toast) => toast.id === toastId);
        const offset = index !== -1
            ? visibleToasts.slice(...(this.defaultConfig.reverseOrder ? [index + 1] : [0, index])).reduce((acc, t, i) => {
                const toastsAfter = visibleToasts.length - 1 - i;
                return this.defaultConfig.visibleToasts !== 0 && i < visibleToasts.length - this.defaultConfig.visibleToasts
                    ? 0
                    : acc +
                        (this.defaultConfig.stacking === 'vertical' || this.isShowingAllToasts
                            ? t.height || 0
                            : toastsAfter * HOT_TOAST_DEPTH_SCALE + HOT_TOAST_DEPTH_SCALE_ADD) +
                        HOT_TOAST_MARGIN;
            }, 0)
            : 0;
        return offset;
    }
    updateHeight(height, toast) {
        toast.height = height;
        this.cdr.detectChanges();
    }
    addToast(ref) {
        this.toastRefs.push(ref);
        const toast = ref.getToast();
        this.toasts.push(ref.getToast());
        if (this.defaultConfig.visibleToasts !== 0 && this.toasts.length > this.defaultConfig.visibleToasts) {
            const closeToasts = this.toasts.slice(0, this.toasts.length - this.defaultConfig.visibleToasts);
            closeToasts.forEach((t) => {
                if (t.autoClose) {
                    this.closeToast(t.id);
                }
            });
        }
        this.cdr.detectChanges();
        return {
            dispose: () => {
                this.closeToast(toast.id);
            },
            updateMessage: (message) => {
                toast.message = message;
                this.updateToasts(toast);
                this.cdr.detectChanges();
            },
            updateToast: (options) => {
                this.updateToasts(toast, options);
                this.cdr.detectChanges();
            },
            afterClosed: this.getAfterClosed(toast),
        };
    }
    closeToast(id) {
        if (id) {
            const comp = this.hotToastComponentList.find((item) => item.toast.id === id);
            if (comp) {
                comp.close();
            }
        }
        else {
            this.hotToastComponentList.forEach((comp) => comp.close());
        }
    }
    beforeClosed(toast) {
        toast.visible = false;
    }
    afterClosed(closeToast) {
        const toastIndex = this.toasts.findIndex((t) => t.id === closeToast.id);
        if (toastIndex > -1) {
            this._onClosed.next(closeToast);
            this.toasts = this.toasts.filter((t) => t.id !== closeToast.id);
            this.toastRefs = this.toastRefs.filter((t) => t.getToast().id !== closeToast.id);
            this.cdr.detectChanges();
        }
    }
    hasToast(id) {
        return this.toasts.findIndex((t) => t.id === id) > -1;
    }
    showAllToasts(show) {
        this.isShowingAllToasts = show;
    }
    getAfterClosed(toast) {
        return this.onClosed$.pipe(filter((v) => v.id === toast.id));
    }
    updateToasts(toast, options) {
        this.toasts = this.toasts.map((t) => ({ ...t, ...(t.id === toast.id && { ...toast, ...options }) }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.1", ngImport: i0, type: HotToastContainerComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.1", type: HotToastContainerComponent, isStandalone: true, selector: "hot-toast-container", inputs: { defaultConfig: "defaultConfig" }, viewQueries: [{ propertyName: "hotToastComponentList", predicate: HotToastComponent, descendants: true }], ngImport: i0, template: "<div style=\"position: fixed; z-index: 9999; top: 0; right: 0; bottom: 0; left: 0; pointer-events: none\">\n  <div style=\"position: relative; height: 100%\">\n    <div>\n      <hot-toast\n        *ngFor=\"let toast of toasts; trackBy: trackById; let i = index\"\n        [toast]=\"toast\"\n        [offset]=\"calculateOffset(toast.id, toast.position)\"\n        [toastRef]=\"toastRefs[i]\"\n        [toastsAfter]=\"(toast.autoClose ? toasts.length : getVisibleToasts(toast.position).length) - 1 - i\"\n        [defaultConfig]=\"defaultConfig\"\n        [isShowingAllToasts]=\"isShowingAllToasts\"\n        (showAllToasts)=\"showAllToasts($event)\"\n        (height)=\"updateHeight($event, toast)\"\n        (beforeClosed)=\"beforeClosed(toast)\"\n        (afterClosed)=\"afterClosed($event)\"\n      ></hot-toast>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: HotToastComponent, selector: "hot-toast", inputs: ["toast", "offset", "defaultConfig", "toastRef", "toastsAfter", "isShowingAllToasts"], outputs: ["height", "beforeClosed", "afterClosed", "showAllToasts"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.1", ngImport: i0, type: HotToastContainerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-container', changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, imports: [CommonModule, HotToastComponent], template: "<div style=\"position: fixed; z-index: 9999; top: 0; right: 0; bottom: 0; left: 0; pointer-events: none\">\n  <div style=\"position: relative; height: 100%\">\n    <div>\n      <hot-toast\n        *ngFor=\"let toast of toasts; trackBy: trackById; let i = index\"\n        [toast]=\"toast\"\n        [offset]=\"calculateOffset(toast.id, toast.position)\"\n        [toastRef]=\"toastRefs[i]\"\n        [toastsAfter]=\"(toast.autoClose ? toasts.length : getVisibleToasts(toast.position).length) - 1 - i\"\n        [defaultConfig]=\"defaultConfig\"\n        [isShowingAllToasts]=\"isShowingAllToasts\"\n        (showAllToasts)=\"showAllToasts($event)\"\n        (height)=\"updateHeight($event, toast)\"\n        (beforeClosed)=\"beforeClosed(toast)\"\n        (afterClosed)=\"afterClosed($event)\"\n      ></hot-toast>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { defaultConfig: [{
                type: Input
            }], hotToastComponentList: [{
                type: ViewChildren,
                args: [HotToastComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90LXRvYXN0LWNvbnRhaW5lci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ25lYXQvaG90LXRvYXN0L3NyYy9saWIvY29tcG9uZW50cy9ob3QtdG9hc3QtY29udGFpbmVyL2hvdC10b2FzdC1jb250YWluZXIuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmduZWF0L2hvdC10b2FzdC9zcmMvbGliL2NvbXBvbmVudHMvaG90LXRvYXN0LWNvbnRhaW5lci9ob3QtdG9hc3QtY29udGFpbmVyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsdUJBQXVCLEVBQXFCLEtBQUssRUFBYSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEgsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFXL0IsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXhDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSx5QkFBeUIsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7QUFTckcsTUFBTSxPQUFPLDBCQUEwQjtJQWNyQyxZQUFvQixHQUFzQjtRQUF0QixRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQVQxQyxXQUFNLEdBQXFCLEVBQUUsQ0FBQztRQUM5QixjQUFTLEdBQWlDLEVBQUUsQ0FBQztRQUM3Qyx1QkFBa0IsR0FBRyxLQUFLLENBQUM7UUFFM0IscUVBQXFFO1FBQzdELGNBQVMsR0FBRyxJQUFJLE9BQU8sRUFBaUIsQ0FBQztRQUV6QyxjQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FB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LENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVPLFlBQVksQ0FBQyxLQUFxQixFQUFFLE9BQXFDO1FBQy9FLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxLQUFLLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxLQUFLLEVBQUUsR0FBRyxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZHLENBQUM7OEdBekhVLDBCQUEwQjtrR0FBMUIsMEJBQTBCLHFLQUd2QixpQkFBaUIsZ0RDNUJqQyxnMUJBbUJBLDJDRElZLFlBQVksNEpBQUUsaUJBQWlCOzsyRkFFOUIsMEJBQTBCO2tCQVB0QyxTQUFTOytCQUNFLHFCQUFxQixtQkFFZCx1QkFBdUIsQ0FBQyxNQUFNLGNBQ25DLElBQUksV0FDUCxDQUFDLFlBQVksRUFBRSxpQkFBaUIsQ0FBQzt3R0FHakMsYUFBYTtzQkFBckIsS0FBSztnQkFFMkIscUJBQXFCO3NCQUFyRCxZQUFZO3VCQUFDLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBJbnB1dCwgUXVlcnlMaXN0LCBWaWV3Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBIb3RUb2FzdENsb3NlLFxuICBUb2FzdCxcbiAgVG9hc3RDb25maWcsXG4gIFRvYXN0UG9zaXRpb24sXG4gIFVwZGF0ZVRvYXN0T3B0aW9ucyxcbiAgQWRkVG9hc3RSZWYsXG4gIENyZWF0ZUhvdFRvYXN0UmVmLFxufSBmcm9tICcuLi8uLi9ob3QtdG9hc3QubW9kZWwnO1xuaW1wb3J0IHsgSG90VG9hc3RSZWYgfSBmcm9tICcuLi8uLi9ob3QtdG9hc3QtcmVmJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbnRlbnQgfSBmcm9tICdAbmduZWF0L292ZXJ2aWV3JztcbmltcG9ydCB7IEhvdFRvYXN0Q29tcG9uZW50IH0gZnJvbSAnLi4vaG90LXRvYXN0L2hvdC10b2FzdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSE9UX1RPQVNUX0RFUFRIX1NDQUxFLCBIT1RfVE9BU1RfREVQVEhfU0NBTEVfQURELCBIT1RfVE9BU1RfTUFSR0lOIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnaG90LXRvYXN0LWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9ob3QtdG9hc3QtY29udGFpbmVyLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEhvdFRvYXN0Q29tcG9uZW50XSxcbn0pXG5leHBvcnQgY2xhc3MgSG90VG9hc3RDb250YWluZXJDb21wb25lbnQge1xuICBASW5wdXQoKSBkZWZhdWx0Q29uZmlnOiBUb2FzdENvbmZpZztcblxuICBAVmlld0NoaWxkcmVuKEhvdFRvYXN0Q29tcG9uZW50KSBob3RUb2FzdENvbXBvbmVudExpc3Q6IFF1ZXJ5TGlzdDxIb3RUb2FzdENvbXBvbmVudD47XG5cbiAgdG9hc3RzOiBUb2FzdDx1bmtub3duPltdID0gW107XG4gIHRvYXN0UmVmczogQ3JlYXRlSG90VG9hc3RSZWY8dW5rbm93bj5bXSA9IFtdO1xuICBpc1Nob3dpbmdBbGxUb2FzdHMgPSBmYWxzZTtcblxuICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgdGhlIHRvYXN0IGhhcyBiZWVuIGNsb3NlZC4gKi9cbiAgcHJpdmF0ZSBfb25DbG9zZWQgPSBuZXcgU3ViamVjdDxIb3RUb2FzdENsb3NlPigpO1xuXG4gIHByaXZhdGUgb25DbG9zZWQkID0gdGhpcy5fb25DbG9zZWQuYXNPYnNlcnZhYmxlKCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7fVxuXG4gIHRyYWNrQnlJZChpbmRleDogbnVtYmVyLCB0b2FzdDogVG9hc3Q8dW5rbm93bj4pIHtcbiAgICByZXR1cm4gdG9hc3QuaWQ7XG4gIH1cblxuICBnZXRWaXNpYmxlVG9hc3RzKHBvc2l0aW9uOiBUb2FzdFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudG9hc3RzLmZpbHRlcigodCkgPT4gdC52aXNpYmxlICYmIHQucG9zaXRpb24gPT09IHBvc2l0aW9uKTtcbiAgfVxuICBjYWxjdWxhdGVPZmZzZXQodG9hc3RJZDogc3RyaW5nLCBwb3NpdGlvbjogVG9hc3RQb3NpdGlvbikge1xuICAgIGNvbnN0IHZpc2libGVUb2FzdHMgPSB0aGlzLmdldFZpc2libGVUb2FzdHMocG9zaXRpb24pO1xuICAgIGNvbnN0IGluZGV4ID0gdmlzaWJsZVRvYXN0cy5maW5kSW5kZXgoKHRvYXN0KSA9PiB0b2FzdC5pZCA9PT0gdG9hc3RJZCk7XG4gICAgY29uc3Qgb2Zmc2V0ID1cbiAgICAgIGluZGV4ICE9PSAtMVxuICAgICAgICA/IHZpc2libGVUb2FzdHMuc2xpY2UoLi4uKHRoaXMuZGVmYXVsdENvbmZpZy5yZXZlcnNlT3JkZXIgPyBbaW5kZXggKyAxXSA6IFswLCBpbmRleF0pKS5yZWR1Y2UoKGFjYywgdCwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9hc3RzQWZ0ZXIgPSB2aXNpYmxlVG9hc3RzLmxlbmd0aCAtIDEgLSBpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENvbmZpZy52aXNpYmxlVG9hc3RzICE9PSAwICYmIGkgPCB2aXNpYmxlVG9hc3RzLmxlbmd0aCAtIHRoaXMuZGVmYXVsdENvbmZpZy52aXNpYmxlVG9hc3RzXG4gICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICA6IGFjYyArXG4gICAgICAgICAgICAgICAgICAodGhpcy5kZWZhdWx0Q29uZmlnLnN0YWNraW5nID09PSAndmVydGljYWwnIHx8IHRoaXMuaXNTaG93aW5nQWxsVG9hc3RzXG4gICAgICAgICAgICAgICAgICAgID8gdC5oZWlnaHQgfHwgMFxuICAgICAgICAgICAgICAgICAgICA6IHRvYXN0c0FmdGVyICogSE9UX1RPQVNUX0RFUFRIX1NDQUxFICsgSE9UX1RPQVNUX0RFUFRIX1NDQUxFX0FERCkgK1xuICAgICAgICAgICAgICAgICAgSE9UX1RPQVNUX01BUkdJTjtcbiAgICAgICAgICB9LCAwKVxuICAgICAgICA6IDA7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHVwZGF0ZUhlaWdodChoZWlnaHQ6IG51bWJlciwgdG9hc3Q6IFRvYXN0PHVua25vd24+KSB7XG4gICAgdG9hc3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIGFkZFRvYXN0PERhdGFUeXBlPihyZWY6IEhvdFRvYXN0UmVmKTogQWRkVG9hc3RSZWY8RGF0YVR5cGU+IHtcbiAgICB0aGlzLnRvYXN0UmVmcy5wdXNoKHJlZik7XG5cbiAgICBjb25zdCB0b2FzdCA9IHJlZi5nZXRUb2FzdCgpO1xuXG4gICAgdGhpcy50b2FzdHMucHVzaChyZWYuZ2V0VG9hc3QoKSk7XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0Q29uZmlnLnZpc2libGVUb2FzdHMgIT09IDAgJiYgdGhpcy50b2FzdHMubGVuZ3RoID4gdGhpcy5kZWZhdWx0Q29uZmlnLnZpc2libGVUb2FzdHMpIHtcbiAgICAgIGNvbnN0IGNsb3NlVG9hc3RzID0gdGhpcy50b2FzdHMuc2xpY2UoMCwgdGhpcy50b2FzdHMubGVuZ3RoIC0gdGhpcy5kZWZhdWx0Q29uZmlnLnZpc2libGVUb2FzdHMpO1xuICAgICAgY2xvc2VUb2FzdHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAodC5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlVG9hc3QodC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2VUb2FzdCh0b2FzdC5pZCk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlTWVzc2FnZTogKG1lc3NhZ2U6IENvbnRlbnQpID0+IHtcbiAgICAgICAgdG9hc3QubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMudXBkYXRlVG9hc3RzKHRvYXN0KTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVRvYXN0OiAob3B0aW9uczogVXBkYXRlVG9hc3RPcHRpb25zPERhdGFUeXBlPikgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVRvYXN0cyh0b2FzdCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH0sXG4gICAgICBhZnRlckNsb3NlZDogdGhpcy5nZXRBZnRlckNsb3NlZCh0b2FzdCksXG4gICAgfTtcbiAgfVxuXG4gIGNsb3NlVG9hc3QoaWQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGNvbnN0IGNvbXAgPSB0aGlzLmhvdFRvYXN0Q29tcG9uZW50TGlzdC5maW5kKChpdGVtKSA9PiBpdGVtLnRvYXN0LmlkID09PSBpZCk7XG4gICAgICBpZiAoY29tcCkge1xuICAgICAgICBjb21wLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaG90VG9hc3RDb21wb25lbnRMaXN0LmZvckVhY2goKGNvbXApID0+IGNvbXAuY2xvc2UoKSk7XG4gICAgfVxuICB9XG5cbiAgYmVmb3JlQ2xvc2VkKHRvYXN0OiBUb2FzdDx1bmtub3duPikge1xuICAgIHRvYXN0LnZpc2libGUgPSBmYWxzZTtcbiAgfVxuXG4gIGFmdGVyQ2xvc2VkKGNsb3NlVG9hc3Q6IEhvdFRvYXN0Q2xvc2UpIHtcbiAgICBjb25zdCB0b2FzdEluZGV4ID0gdGhpcy50b2FzdHMuZmluZEluZGV4KCh0KSA9PiB0LmlkID09PSBjbG9zZVRvYXN0LmlkKTtcbiAgICBpZiAodG9hc3RJbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLl9vbkNsb3NlZC5uZXh0KGNsb3NlVG9hc3QpO1xuICAgICAgdGhpcy50b2FzdHMgPSB0aGlzLnRvYXN0cy5maWx0ZXIoKHQpID0+IHQuaWQgIT09IGNsb3NlVG9hc3QuaWQpO1xuICAgICAgdGhpcy50b2FzdFJlZnMgPSB0aGlzLnRvYXN0UmVmcy5maWx0ZXIoKHQpID0+IHQuZ2V0VG9hc3QoKS5pZCAhPT0gY2xvc2VUb2FzdC5pZCk7XG4gICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICB9XG5cbiAgaGFzVG9hc3QoaWQ6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnRvYXN0cy5maW5kSW5kZXgoKHQpID0+IHQuaWQgPT09IGlkKSA+IC0xO1xuICB9XG5cbiAgc2hvd0FsbFRvYXN0cyhzaG93OiBib29sZWFuKSB7XG4gICAgdGhpcy5pc1Nob3dpbmdBbGxUb2FzdHMgPSBzaG93O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBZnRlckNsb3NlZCh0b2FzdDogVG9hc3Q8dW5rbm93bj4pIHtcbiAgICByZXR1cm4gdGhpcy5vbkNsb3NlZCQucGlwZShmaWx0ZXIoKHYpID0+IHYuaWQgPT09IHRvYXN0LmlkKSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVRvYXN0cyh0b2FzdDogVG9hc3Q8dW5rbm93bj4sIG9wdGlvbnM/OiBVcGRhdGVUb2FzdE9wdGlvbnM8dW5rbm93bj4pIHtcbiAgICB0aGlzLnRvYXN0cyA9IHRoaXMudG9hc3RzLm1hcCgodCkgPT4gKHsgLi4udCwgLi4uKHQuaWQgPT09IHRvYXN0LmlkICYmIHsgLi4udG9hc3QsIC4uLm9wdGlvbnMgfSkgfSkpO1xuICB9XG59XG4iLCI8ZGl2IHN0eWxlPVwicG9zaXRpb246IGZpeGVkOyB6LWluZGV4OiA5OTk5OyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IGxlZnQ6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lXCI+XG4gIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7IGhlaWdodDogMTAwJVwiPlxuICAgIDxkaXY+XG4gICAgICA8aG90LXRvYXN0XG4gICAgICAgICpuZ0Zvcj1cImxldCB0b2FzdCBvZiB0b2FzdHM7IHRyYWNrQnk6IHRyYWNrQnlJZDsgbGV0IGkgPSBpbmRleFwiXG4gICAgICAgIFt0b2FzdF09XCJ0b2FzdFwiXG4gICAgICAgIFtvZmZzZXRdPVwiY2FsY3VsYXRlT2Zmc2V0KHRvYXN0LmlkLCB0b2FzdC5wb3NpdGlvbilcIlxuICAgICAgICBbdG9hc3RSZWZdPVwidG9hc3RSZWZzW2ldXCJcbiAgICAgICAgW3RvYXN0c0FmdGVyXT1cIih0b2FzdC5hdXRvQ2xvc2UgPyB0b2FzdHMubGVuZ3RoIDogZ2V0VmlzaWJsZVRvYXN0cyh0b2FzdC5wb3NpdGlvbikubGVuZ3RoKSAtIDEgLSBpXCJcbiAgICAgICAgW2RlZmF1bHRDb25maWddPVwiZGVmYXVsdENvbmZpZ1wiXG4gICAgICAgIFtpc1Nob3dpbmdBbGxUb2FzdHNdPVwiaXNTaG93aW5nQWxsVG9hc3RzXCJcbiAgICAgICAgKHNob3dBbGxUb2FzdHMpPVwic2hvd0FsbFRvYXN0cygkZXZlbnQpXCJcbiAgICAgICAgKGhlaWdodCk9XCJ1cGRhdGVIZWlnaHQoJGV2ZW50LCB0b2FzdClcIlxuICAgICAgICAoYmVmb3JlQ2xvc2VkKT1cImJlZm9yZUNsb3NlZCh0b2FzdClcIlxuICAgICAgICAoYWZ0ZXJDbG9zZWQpPVwiYWZ0ZXJDbG9zZWQoJGV2ZW50KVwiXG4gICAgICA+PC9ob3QtdG9hc3Q+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG4iXX0=